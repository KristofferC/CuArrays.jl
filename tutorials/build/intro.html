<!DOCTYPE html>
<HTML lang = "en">
<HEAD>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>A gentle introduction to parallelization and GPU programming in Julia</title>
  

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>

  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  <style type="text/css">
  @font-face {
  font-style: normal;
  font-weight: 300;
}
@font-face {
  font-style: normal;
  font-weight: 400;
}
@font-face {
  font-style: normal;
  font-weight: 600;
}
html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}
body {
  margin: 0;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}
audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}
audio:not([controls]) {
  display: none;
  height: 0;
}
[hidden],
template {
  display: none;
}
a:active,
a:hover {
  outline: 0;
}
abbr[title] {
  border-bottom: 1px dotted;
}
b,
strong {
  font-weight: bold;
}
dfn {
  font-style: italic;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
mark {
  background: #ff0;
  color: #000;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}
img {
  border: 0;
}
svg:not(:root) {
  overflow: hidden;
}
figure {
  margin: 1em 40px;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}
pre {
  overflow: auto;
}
code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}
button {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}
button[disabled],
html input[disabled] {
  cursor: default;
}
button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
input {
  line-height: normal;
}
input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}
legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}
textarea {
  overflow: auto;
}
optgroup {
  font-weight: bold;
}
table {
  font-family: monospace, monospace;
  font-size : 0.8em;
  border-collapse: collapse;
  border-spacing: 0;
}
td,
th {
  padding: 0;
}
thead th {
    border-bottom: 1px solid black;
    background-color: white;
}
tr:nth-child(odd){
  background-color: rgb(248,248,248);
}


/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 3.6rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.4rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.2rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.8rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 2.4rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

p {
  margin-top: 0; }
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }
ul {
  list-style: circle; }
ol {
  list-style: decimal; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li {
  margin-bottom: 1rem; }
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 2.5rem; }
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }

pre {
  display: block;
  padding: 9.5px;
  margin: 0 0 10px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #333;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #ffffff;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre.sourceCode.julia {
  display: block;
  padding: 9.5px;
  margin: 0 0 10px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #333;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre.julia-error {
  color : red
}

code,
kbd,
pre,
samp {
  font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
}
code {
  padding: 2px 4px;
  font-size: 90%;

  background-color: #ffffff;
  border-radius: 4px;
}

@media (min-width: 400px) {}
@media (min-width: 550px) {}
@media (min-width: 750px) {}
@media (min-width: 1000px) {}
@media (min-width: 1200px) {}

h1.title {margin-top : 20px}
img {max-width : 100%}
div.title {text-align: center;}

  </style>

  
<style>
pre.hljl {
    border: 1px solid #ccc;
    margin: 5px;
    padding: 5px;
    overflow-x: auto;
    color: rgb(68,68,68); background-color: rgb(251,251,251); }
pre.hljl > span.hljl-t { }
pre.hljl > span.hljl-w { }
pre.hljl > span.hljl-e { }
pre.hljl > span.hljl-eB { }
pre.hljl > span.hljl-o { }
pre.hljl > span.hljl-k { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kc { color: rgb(59,151,46); font-style: italic; }
pre.hljl > span.hljl-kd { color: rgb(214,102,97); font-style: italic; }
pre.hljl > span.hljl-kn { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kp { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kr { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kt { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-n { }
pre.hljl > span.hljl-na { }
pre.hljl > span.hljl-nb { }
pre.hljl > span.hljl-nbp { }
pre.hljl > span.hljl-nc { }
pre.hljl > span.hljl-ncB { }
pre.hljl > span.hljl-nd { color: rgb(214,102,97); }
pre.hljl > span.hljl-ne { }
pre.hljl > span.hljl-neB { }
pre.hljl > span.hljl-nf { color: rgb(66,102,213); }
pre.hljl > span.hljl-nfm { color: rgb(66,102,213); }
pre.hljl > span.hljl-np { }
pre.hljl > span.hljl-nl { }
pre.hljl > span.hljl-nn { }
pre.hljl > span.hljl-no { }
pre.hljl > span.hljl-nt { }
pre.hljl > span.hljl-nv { }
pre.hljl > span.hljl-nvc { }
pre.hljl > span.hljl-nvg { }
pre.hljl > span.hljl-nvi { }
pre.hljl > span.hljl-nvm { }
pre.hljl > span.hljl-l { }
pre.hljl > span.hljl-ld { color: rgb(148,91,176); font-style: italic; }
pre.hljl > span.hljl-s { color: rgb(201,61,57); }
pre.hljl > span.hljl-sa { color: rgb(201,61,57); }
pre.hljl > span.hljl-sb { color: rgb(201,61,57); }
pre.hljl > span.hljl-sc { color: rgb(201,61,57); }
pre.hljl > span.hljl-sd { color: rgb(201,61,57); }
pre.hljl > span.hljl-sdB { color: rgb(201,61,57); }
pre.hljl > span.hljl-sdC { color: rgb(201,61,57); }
pre.hljl > span.hljl-se { color: rgb(59,151,46); }
pre.hljl > span.hljl-sh { color: rgb(201,61,57); }
pre.hljl > span.hljl-si { }
pre.hljl > span.hljl-so { color: rgb(201,61,57); }
pre.hljl > span.hljl-sr { color: rgb(201,61,57); }
pre.hljl > span.hljl-ss { color: rgb(201,61,57); }
pre.hljl > span.hljl-ssB { color: rgb(201,61,57); }
pre.hljl > span.hljl-nB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nbB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nfB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nh { color: rgb(59,151,46); }
pre.hljl > span.hljl-ni { color: rgb(59,151,46); }
pre.hljl > span.hljl-nil { color: rgb(59,151,46); }
pre.hljl > span.hljl-noB { color: rgb(59,151,46); }
pre.hljl > span.hljl-oB { color: rgb(102,102,102); font-weight: bold; }
pre.hljl > span.hljl-ow { color: rgb(102,102,102); font-weight: bold; }
pre.hljl > span.hljl-p { }
pre.hljl > span.hljl-c { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-ch { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cm { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cp { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cpB { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cs { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-csB { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-g { }
pre.hljl > span.hljl-gd { }
pre.hljl > span.hljl-ge { }
pre.hljl > span.hljl-geB { }
pre.hljl > span.hljl-gh { }
pre.hljl > span.hljl-gi { }
pre.hljl > span.hljl-go { }
pre.hljl > span.hljl-gp { }
pre.hljl > span.hljl-gs { }
pre.hljl > span.hljl-gsB { }
pre.hljl > span.hljl-gt { }
</style>



</HEAD>
  <BODY>
    <div class ="container">
      <div class = "row">
        <div class = "col-md-12 twelve columns">

          <div class="title">
            <h1 class="title">A gentle introduction to parallelization and GPU programming in Julia</h1>
            <h5>Tim Holy</h5>
            <h5>18th December 2018</h5>
          </div>

          
<p><a href="https://julialang.org/">Julia</a> has first-class support for GPU programming: you can use high-level abstractions or obtain fine-grained control, all without ever leaving your favorite programming language. The purpose of this tutorial is to help Julia users take their first step into GPU computing. In this tutorial, you&#39;ll compare CPU and GPU implementations of a simple calculation, and learn about a few of the factors that influence the performance you obtain.</p>

<p>This tutorial is inspired partly by a blog post by Mark Harris, <a href="https://devblogs.nvidia.com/even-easier-introduction-cuda/">An Even Easier Introduction to CUDA</a>, which introduced CUDA using the C&#43;&#43; programming language. You do not need to read that tutorial, as this one starts from the beginning.</p>

<h1>A simple example on the CPU</h1>

<p>We&#39;ll consider the following demo, a simple calculation on the CPU.</p>


<pre class='hljl'>
<span class='hljl-n'>N</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-oB'>^</span><span class='hljl-ni'>20</span><span class='hljl-t'>
</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector filled with 1.0 (Float32)</span><span class='hljl-t'>
</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector filled with 2.0</span><span class='hljl-t'>

</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>.+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>             </span><span class='hljl-cs'># increment each element of y with the corresponding element of x</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Test</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span><span class='hljl-t'>   </span><span class='hljl-cs'># check that we got the right answer</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>From the <code>Test Passed</code> line we know everything is in order. We used <code>Float32</code> numbers in preparation for the switch to GPU computations: GPUs are faster &#40;sometimes, much faster&#41; when working with <code>Float32</code> than with <code>Float64</code>.</p>

<p>A distinguishing feature of this calculation is that every element of <code>y</code> is being updated using the same operation. This suggests that we might be able to parallelize this.</p>

<h2>Parallelization on the CPU</h2>

<p>First let&#39;s do the parallelization on the CPU. We&#39;ll create a &quot;kernel function&quot; &#40;the computational core of the algorithm&#41; in two implementations, one sequential and the other parallel:</p>


<pre class='hljl'>
<span class='hljl-cs'># Sequential implementation</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>sequential_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-nf'>eachindex</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-cs'># Parallel implementation</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>parallel_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>Threads</span><span class='hljl-oB'>.</span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-nf'>eachindex</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>sequential_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>parallel_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>Now if I&#39;ve started julia with <code>JULIA_NUM_THREADS&#61;4</code> on a machine with at least 4 cores, I get the following:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>sequential_add!</span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
384.464 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<p>versus</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>parallel_add!</span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
97.925 μs &#40;1 allocation: 32 bytes&#41;
</pre>


<p>You can see there&#39;s a performance benefit to parallelization, though not by a full factor of 4 due to the overhead for starting threads. With larger arrays, the overhead would be &quot;diluted&quot; by a larger amount of &quot;real work&quot;; these would demonstrate scaling that is closer to linear in the number of cores. Conversely, with small arrays, the parallel version might be slower than the serial version.</p>

<h1>Your first GPU computation</h1>

<h2>Installation</h2>

<p>For most of this tutorial you need to have a computer with a compatible GPU and have installed <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>. You should also install the following packages using Julia&#39;s <a href="https://docs.julialang.org/en/latest/stdlib/Pkg/">package manager</a>:</p>

<pre><code class="language-julia">pkg&gt; add CUDAdrv CUDAnative CuArrays</code></pre>

<p>If this is your first time, it&#39;s not a bad idea to test whether your GPU is working:</p>

<pre><code class="language-julia">pkg&gt; test CuArrays</code></pre>

<h2>Parallelization on the GPU</h2>

<p>We&#39;ll first demonstrate GPU computations at a high level, without explicitly writing a kernel function:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>CuArrays</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>CUDAdrv</span><span class='hljl-t'>

</span><span class='hljl-n'>x_d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cufill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector stored on the GPU filled with 1.0 (Float32)</span><span class='hljl-t'>
</span><span class='hljl-n'>y_d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cufill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector stored on the GPU filled with 2.0</span>
</pre>



<p>Here the <code>d</code> means &quot;device,&quot; in contrast with &quot;host.&quot; Now let&#39;s do the increment:</p>


<pre class='hljl'>
<span class='hljl-n'>y_d</span><span class='hljl-t'> </span><span class='hljl-oB'>.+=</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>The statement <code>Array&#40;y_d&#41;</code> moves the data in <code>y_d</code> back to the host for testing. If we want to benchmark this, let&#39;s put it in a function:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>add_broadcast!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>.+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-nf'>synchronize</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>add_broadcast!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
106.278 μs &#40;37 allocations: 1.70 KiB&#41;
</pre>


<p>The most interesting part of this is the call to <code>synchronize</code> from the <code>CUDAdrv</code> package. The CPU can assign jobs to the GPU and then go do other stuff &#40;such as assigning <em>more</em> jobs to the GPU&#41; while the GPU completes its tasks. <code>synchronize</code> forces execution to pause until the queued tasks are done. Without the <code>synchronize</code>, you&#39;d be measuring the time takes to launch the computation, not the time to perform the computation.</p>

<p>For this particular computer and GPU, you can see the GPU computation was significantly faster than the single-threaded CPU computation, and that the use of CPU threads makes the two competitive with one another. Depending on your hardware you may get different results.</p>

<h2>Writing your first GPU kernel</h2>

<p>Using the high-level functionality of CuArrays made it easy to perform this computation on the GPU. However, we didn&#39;t learn about what&#39;s going on under the hood, and that&#39;s the main goal of this tutorial. So let&#39;s implement the same functionality with a GPU kernel.</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add1!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>CUDAnative</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add1!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>Aside from using the <code>CuArray</code>s <code>x_d</code> and <code>y_d</code>, the only GPU-specific part of this is the <em>kernel launch</em> via <code>@cuda</code>, defined in the <code>CUDAnative</code> package. The first time you issue this <code>@cuda</code> statement, it will compile the kernel &#40;<code>gpu_add1&#33;</code>&#41; for execution on the GPU. Once compiled, future invocations are fast. You can see what <code>@cuda</code> expands to using <code>?@cuda</code> from the Julia prompt.</p>

<p>Let&#39;s benchmark this:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu1!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add1!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nf'>synchronize</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu1!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
358.289 ms &#40;16 allocations: 528 bytes&#41;
</pre>


<p>That&#39;s a <em>lot</em> slower than version above based on broadcasting. What happened?</p>

<h2>Profiling</h2>

<p>When you don&#39;t get the performance you expect, usually your first step should be to profile the code and see where it&#39;s spending its time. For that you&#39;ll need to be able to run NVIDIA&#39;s <a href="https://devblogs.nvidia.com/cuda-pro-tip-nvprof-your-handy-universal-gpu-profiler/"><code>nvprof</code> tool</a>. On Unix systems, launch Julia this way:</p>
<pre><code class="language-sh">&#36; nvprof --profile-from-start off /usr/local/bin/julia</code></pre>
<p>replacing the <code>/usr/local/bin/julia</code> with the path to your Julia binary. After you&#39;ve redefined all the necessary variables and methods, you can use</p>

<pre><code class="language-julia">julia&gt; bench_gpu1&#33;&#40;y_d, x_d&#41;  # run it once to force compilation
julia&gt; CUDAdrv.@profile bench_gpu1&#33;&#40;y_d, x_d&#41;</code></pre>

<p>and then quit Julia. I get output like this:</p>
<pre><code class="language-sh">&#61;&#61;21904&#61;&#61; NVPROF is profiling process 21904, command: /usr/local/julia/julia-1.0/julia /tmp/tim/cuprofile.jl
&#61;&#61;21904&#61;&#61; Profiling application: /usr/local/julia/julia-1.0/julia /tmp/tim/cuprofile.jl
&#61;&#61;21904&#61;&#61; Profiling result:
Time&#40;&#37;&#41;      Time     Calls       Avg       Min       Max  Name
100.00&#37;  357.39ms         1  357.39ms  357.39ms  357.39ms  ptxcall_gpu_add1__1

&#61;&#61;21904&#61;&#61; API calls:
Time&#40;&#37;&#41;      Time     Calls       Avg       Min       Max  Name
 99.56&#37;  357.39ms         1  357.39ms  357.39ms  357.39ms  cuCtxSynchronize
  0.30&#37;  1.0910ms         1  1.0910ms  1.0910ms  1.0910ms  cuLaunchKernel
  0.13&#37;  481.99us         2  241.00us     610ns  481.38us  cuCtxGetCurrent</code></pre>

<p>You can see that 100&#37; of the time was spent in <code>ptxcall_gpu_add1__1</code>, the name of the kernel that <code>CUDAnative</code> assigned when compiling <code>gpu_add1&#33;</code> for these inputs. &#40;Had you created arrays of multiple data types, e.g., <code>xu_d &#61; cufill&#40;0x01, N&#41;</code>, you might have also seen <code>ptxcall_gpu_add1__2</code> and so on. Like the rest of Julia, you can define a single method and it will be specialized at compile time for the particular data types you&#39;re using.&#41;</p>

<p>For further insight, run the profiling with the option</p>
<pre><code class="language-julia">&#36; nvprof --profile-from-start off --print-gpu-trace /usr/local/bin/julia /tmp/cuprofile.jl</code></pre>
<p>where here I&#39;ve put all the commands I want to run &#40;including the <code>CUDAdrv.@profile</code>&#41; into a script <code>/tmp/cuprofile.jl</code>. Then I see</p>
<pre><code class="language-sh">&#61;&#61;24101&#61;&#61; NVPROF is profiling process 24101, command: /usr/local/julia/julia-1.0/julia /tmp/tim/cuprofile.jl
&#61;&#61;24101&#61;&#61; Profiling application: /usr/local/julia/julia-1.0/julia /tmp/tim/cuprofile.jl
&#61;&#61;24101&#61;&#61; Profiling result:
   Start  Duration            Grid Size      Block Size     Regs*    SSMem*    DSMem*      Size  Throughput           Device   Context    Stream  Name
19.9962s  357.72ms              &#40;1 1 1&#41;         &#40;1 1 1&#41;        19        0B        0B         -           -   Tesla K20c &#40;0&#41;         1         7  ptxcall_gpu_add1__1 &#91;27&#93;

Regs: Number of registers used per CUDA thread. This number includes registers used internally by the CUDA driver and/or tools and can be more than what the compiler shows.
SSMem: Static shared memory allocated per CUDA block.
DSMem: Dynamic shared memory allocated per CUDA block.</code></pre>

<p>The key thing to note here is the <code>&#40;1 1 1&#41;</code> in the &quot;Grid Size&quot; and &quot;Block Size&quot; columns. These terms will be explained shortly, but for now suffice it to say that this is an indication that this computation ran sequentially. Of note, sequential processing with GPUs is much slower than with CPUs; where GPUs shine is with large-scale parallelism.</p>

<h2>Writing a parallel GPU kernel</h2>

<p>To speed up the kernel, we want to parallelize it, which means assigning different tasks to different threads.  To facilitate the assignment of work, each CUDA thread gets access to variables that indicate its own unique identity, much as <a href="https://docs.julialang.org/en/latest/manual/parallel-computing/#Multi-Threading-&#40;Experimental&#41;-1"><code>Threads.threadid&#40;&#41;</code></a> does for CPU threads. The CUDA analogs of <code>threadid</code> and <code>nthreads</code> are called <code>threadIdx</code> and <code>blockDim</code>, respectively; one difference is that these return a 3-dimensional structure with fields <code>x</code>, <code>y</code>, and <code>z</code> to simplify cartesian indexing for up to 3-dimensional arrays. Consequently we can assign unique work in the following way:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>index</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>threadIdx</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>    </span><span class='hljl-cs'># this example only requires linear indexing, so just use `x`</span><span class='hljl-t'>
    </span><span class='hljl-n'>stride</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>blockDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>index</span><span class='hljl-oB'>:</span><span class='hljl-n'>stride</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>256</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>Note the <code>threads&#61;256</code> here, which divides the work among 256 threads numbered in a linear pattern. &#40;For a two dimensional array, we might have used <code>threads&#61;&#40;16, 16&#41;</code> and then both <code>x</code> and <code>y</code> would be relevant.&#41;</p>

<p>Now let&#39;s try benchmarking it:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>256</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nf'>synchronize</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
2.367 ms &#40;19 allocations: 608 bytes&#41;
</pre>


<p>Much better&#33;</p>

<p>But obviously we still have a ways to go to match the initial broadcasting result. To do even better, we need to parallelize more. GPUs have a limited number of threads they can run on a single <em>streaming multiprocessor</em> &#40;SM&#41;, but they also have multiple SMs. To take advantage of them all, we need to run a kernel with multiple <em>blocks</em>. We&#39;ll divide up the work like this: <img src="intro1.png" alt="block grid" /> Note that this diagram was <a href="https://devblogs.nvidia.com/even-easier-introduction-cuda/">borrowed from a description of the C/C&#43;&#43; libary</a>; in Julia, threads and blocks begin numbering with 1 instead of 0. In this diagram, the 4096 blocks of 256 threads &#40;making 1048576 &#61; 2^20 threads&#41; ensures that each thread increments just a single entry; however, to ensure that arrays of arbitrary size can be handled, let&#39;s still use a loop:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add3!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>index</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-nf'>blockIdx</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>blockDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nf'>threadIdx</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-n'>stride</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>blockDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-nf'>gridDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>index</span><span class='hljl-oB'>:</span><span class='hljl-n'>stride</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-n'>numblocks</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>ceil</span><span class='hljl-p'>(</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-oB'>/</span><span class='hljl-ni'>256</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>256</span><span class='hljl-t'> </span><span class='hljl-n'>blocks</span><span class='hljl-oB'>=</span><span class='hljl-n'>numblocks</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add3!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@test</span><span class='hljl-t'> </span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
Test Passed
</pre>


<p>The benchmark:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu3!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>numblocks</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>ceil</span><span class='hljl-p'>(</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-oB'>/</span><span class='hljl-ni'>256</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>256</span><span class='hljl-t'> </span><span class='hljl-n'>blocks</span><span class='hljl-oB'>=</span><span class='hljl-n'>numblocks</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add3!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nf'>synchronize</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>bench_gpu3!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span>
</pre>


<pre class="hljl">
131.089 μs &#40;20 allocations: 656 bytes&#41;
</pre>


<p>Finally, we&#39;ve achieved the similar performance to what we got with the broadcasted version. If you use <code>nvprof</code> here, you should see a line like</p>

<pre><code class="language-sh">22.1926s  122.56us           &#40;4096 1 1&#41;       &#40;256 1 1&#41;        32        0B        0B         -           -   Tesla K20c &#40;0&#41;         1         7  ptxcall_gpu_add3__3 &#91;67&#93;</code></pre>

<p>demonstrating this this computation used multiple blocks and threads.</p>

<h2>Printing</h2>

<p>When debugging, it&#39;s not uncommon to want to print some values. This is achieved with <code>@cuprintf</code>:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2_print!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>index</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>threadIdx</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>    </span><span class='hljl-cs'># this example only requires linear indexing, so just use `x`</span><span class='hljl-t'>
    </span><span class='hljl-n'>stride</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>blockDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@cuprintf</span><span class='hljl-p'>(</span><span class='hljl-s'>&quot;threadIdx %ld, blockDim %ld</span><span class='hljl-se'>\n</span><span class='hljl-s'>&quot;</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>index</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>stride</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>index</span><span class='hljl-oB'>:</span><span class='hljl-n'>stride</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>16</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2_print!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>synchronize</span><span class='hljl-p'>()</span>
</pre>


<pre class="hljl">
threadIdx 1, blockDim 16
threadIdx 2, blockDim 16
threadIdx 3, blockDim 16
threadIdx 4, blockDim 16
threadIdx 5, blockDim 16
threadIdx 6, blockDim 16
threadIdx 7, blockDim 16
threadIdx 8, blockDim 16
threadIdx 9, blockDim 16
threadIdx 10, blockDim 16
threadIdx 11, blockDim 16
threadIdx 12, blockDim 16
threadIdx 13, blockDim 16
threadIdx 14, blockDim 16
threadIdx 15, blockDim 16
threadIdx 16, blockDim 16
</pre>


<p>Note that the printed output is generated when running <code>synchronize</code>.</p>

<h2>Error-handling</h2>

<p>The final topic of this intro concerns the handling of errors. Note that the kernels above used <code>@inbounds</code>, but did not check whether <code>y</code> and <code>x</code> have the same length. If they don&#39;t, you can get errors like this:</p>
<pre><code class="language-julia">ERROR: CUDA error: an illegal memory access was encountered &#40;code #700, ERROR_ILLEGAL_ADDRESS&#41;
Stacktrace:
 &#91;1&#93; macro expansion at /home/tim/.julia/dev/CUDAdrv/src/base.jl:147 &#91;inlined&#93;
 &#91;2&#93; synchronize&#40;::CuContext&#41; at /home/tim/.julia/dev/CUDAdrv/src/context.jl:183 &#40;repeats 2 times&#41;
 &#91;3&#93; top-level scope at none:0</code></pre>
<p>If you remove the <code>@inbounds</code> annotation, instead you get</p>
<pre><code class="language-julia">ERROR: a boundserror exception occurred during kernel execution
Error During Test at REPL&#91;14&#93;:1
  Test threw exception
  Expression: all&#40;Array&#40;y_d&#41; .&#61;&#61; 3.0f0&#41;
  CUDA error: an illegal instruction was encountered &#40;code #715, ERROR_ILLEGAL_INSTRUCTION&#41;
  Stacktrace:
   &#91;1&#93; #download&#33;#11&#40;::Bool, ::Function, ::Ptr&#123;Float32&#125;, ::CUDAdrv.Mem.Buffer, ::Int64, ::CuStream&#41; at /home/tim/.julia/dev/CUDAdrv/src/memory.jl:254
   &#91;2&#93; download&#33; at /home/tim/.julia/dev/CUDAdrv/src/memory.jl:248 &#91;inlined&#93; &#40;repeats 2 times&#41;
   &#91;3&#93; unsafe_copyto&#33; at /home/tim/.julia/dev/CuArrays/src/array.jl:166 &#91;inlined&#93;
   &#91;4&#93; copyto&#33; at /home/tim/.julia/packages/GPUArrays/HmVTY/src/abstractarray.jl:110 &#91;inlined&#93;
   &#91;5&#93; Array&#123;Float32,1&#125;&#40;::CuArray&#123;Float32,1&#125;&#41; at ./array.jl:497
   &#91;6&#93; Array&#40;::CuArray&#123;Float32,1&#125;&#41; at ./boot.jl:418
   &#91;7&#93; top-level scope at none:0
   &#91;8&#93; eval&#40;::Module, ::Any&#41; at ./boot.jl:319
   &#91;9&#93; eval_user_input&#40;::Any, ::REPL.REPLBackend&#41; at /usr/local/julia/julia-1.0/usr/share/julia/stdlib/v1.0/REPL/src/REPL.jl:85
   &#91;10&#93; run_backend&#40;::REPL.REPLBackend&#41; at /home/tim/.julia/packages/Revise/gStbk/src/Revise.jl:771
   &#91;11&#93; &#40;::getfield&#40;Revise, Symbol&#40;&quot;##58#60&quot;&#41;&#41;&#123;REPL.REPLBackend&#125;&#41;&#40;&#41; at ./task.jl:259
ERROR: There was an error during testing</code></pre>
<p>If you want the performance advantage of <code>@inbounds</code> but want to use it more safely, you can do manual bounds-checks:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add1_safe!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-nf'>size</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-nf'>size</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-nf'>throw</span><span class='hljl-p'>(</span><span class='hljl-n'>CUDAdrv</span><span class='hljl-oB'>.</span><span class='hljl-n'>ERROR_ILLEGAL_ADDRESS</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="hljl">
gpu_add1_safe&#33; &#40;generic function with 1 method&#41;
</pre>


<p>Any errors typically corrupt the CUDA context, and require you to restart Julia. As a consequence, it&#39;s often a good idea to perform your &quot;sanity checks&quot; using code that runs on the CPU, and only turn over the computation to the GPU once you&#39;ve deemed it to be safe.</p>

<h1>Summary</h1>

<p>Keep in mind that the high-level functionality of CuArrays often means that you don&#39;t need to worry about writing kernels at such a low level. However, there are many cases where computations can be optimized using clever low-level manipulations. Hopefully, you now feel comfortable taking the plunge</p>



          <HR/>
          <div class="footer"><p>
          Published from <a href="intro.jl">intro.jl</a> using
          <a href="http://github.com/mpastell/Weave.jl">Weave.jl</a>
           on 2018-12-20.
          <p></div>


        </div>
      </div>
    </div>
  </BODY>
</HTML>
